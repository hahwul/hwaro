# Completion command for generating shell completion scripts
#
# This command generates shell completion scripts for bash, zsh, and fish.
# Usage:
#   hwaro completion bash  - Generate bash completion script
#   hwaro completion zsh   - Generate zsh completion script
#   hwaro completion fish  - Generate fish completion script

require "option_parser"
require "../metadata"
require "../../utils/logger"

module Hwaro
  module CLI
    module Commands
      class CompletionCommand
        SHELLS = ["bash", "zsh", "fish"]

        def run(args : Array(String))
          shell : String? = nil

          OptionParser.parse(args) do |parser|
            parser.banner = "Usage: hwaro completion <bash|zsh|fish>"
            parser.on("-h", "--help", "Show this help") do
              print_help
              exit
            end
            parser.unknown_args do |unknown|
              shell = unknown.first? if unknown.any?
            end
          end

          unless shell
            print_help
            exit(1)
          end

          case shell.not_nil!.downcase
          when "bash"
            puts generate_bash
          when "zsh"
            puts generate_zsh
          when "fish"
            puts generate_fish
          else
            Logger.error "Unknown shell: #{shell}"
            Logger.info "Supported shells: #{SHELLS.join(", ")}"
            exit(1)
          end
        end

        private def print_help
          Logger.info "Usage: hwaro completion <bash|zsh|fish>"
          Logger.info ""
          Logger.info "Generate shell completion scripts for hwaro."
          Logger.info ""
          Logger.info "Supported shells:"
          Logger.info "  bash   Generate bash completion script"
          Logger.info "  zsh    Generate zsh completion script"
          Logger.info "  fish   Generate fish completion script"
          Logger.info ""
          Logger.info "Examples:"
          Logger.info "  # Bash (add to ~/.bashrc)"
          Logger.info "  eval \"$(hwaro completion bash)\""
          Logger.info ""
          Logger.info "  # Zsh (add to ~/.zshrc)"
          Logger.info "  eval \"$(hwaro completion zsh)\""
          Logger.info ""
          Logger.info "  # Fish (add to ~/.config/fish/config.fish)"
          Logger.info "  hwaro completion fish | source"
        end

        private def generate_bash : String
          commands = Metadata.commands
          command_names = commands.map(&.name).join(" ") + " version help"

          script = <<-BASH
          # hwaro bash completion script
          # Generated by hwaro completion bash
          #
          # Installation:
          #   eval "$(hwaro completion bash)"
          # Or save to a file:
          #   hwaro completion bash > /etc/bash_completion.d/hwaro

          _hwaro_completions() {
              local cur prev words cword
              _init_completion || return

              local commands="#{command_names}"

              # Handle completion based on position and previous word
              case $cword in
                  1)
                      # First argument: complete commands
                      COMPREPLY=($(compgen -W "$commands" -- "$cur"))
                      return 0
                      ;;
                  *)
                      # Get the command (first argument after hwaro)
                      local cmd="${words[1]}"

                      case "$cmd" in
          BASH

          # Add command-specific completions
          commands.each do |cmd|
            script += generate_bash_command_case(cmd)
          end

          script += <<-BASH
                          version|help)
                              return 0
                              ;;
                      esac
                      ;;
              esac

              return 0
          }

          complete -F _hwaro_completions hwaro
          BASH

          script
        end

        private def generate_bash_command_case(cmd : CommandInfo) : String
          flags = cmd.flags.flat_map { |f| [f.short, f.long].compact }.join(" ")

          result = "                    #{cmd.name})\n"

          # Handle subcommands
          if !cmd.subcommands.empty?
            subcommand_names = cmd.subcommands.map(&.name).join(" ")
            result += <<-BASH
                                if [[ $cword -eq 2 ]]; then
                                    COMPREPLY=($(compgen -W "#{subcommand_names}" -- "$cur"))
                                    return 0
                                fi
                                local subcmd="${words[2]}"
                                case "$subcmd" in
            BASH

            cmd.subcommands.each do |sub|
              sub_flags = sub.flags.flat_map { |f| [f.short, f.long].compact }.join(" ")
              sub_choices = sub.positional_choices.join(" ")

              result += "                            #{sub.name})\n"
              if !sub_choices.empty?
                result += "                                if [[ $cword -eq 3 ]]; then\n"
                result += "                                    COMPREPLY=($(compgen -W \"#{sub_choices}\" -- \"$cur\"))\n"
                result += "                                else\n"
                result += "                                    COMPREPLY=($(compgen -W \"#{sub_flags}\" -- \"$cur\"))\n"
                result += "                                fi\n"
              else
                result += "                                COMPREPLY=($(compgen -W \"#{sub_flags}\" -- \"$cur\"))\n"
              end
              result += "                                ;;\n"
            end

            result += "                        esac\n"
          elsif !cmd.positional_choices.empty?
            choices = cmd.positional_choices.join(" ")
            result += <<-BASH
                                if [[ $cword -eq 2 ]]; then
                                    COMPREPLY=($(compgen -W "#{choices}" -- "$cur"))
                                else
                                    COMPREPLY=($(compgen -W "#{flags}" -- "$cur"))
                                fi
            BASH
          else
            result += "                            COMPREPLY=($(compgen -W \"#{flags}\" -- \"$cur\"))\n"
          end

          result += "                            ;;\n"
          result
        end

        private def generate_zsh : String
          commands = Metadata.commands

          script = <<-ZSH
          #compdef hwaro

          # hwaro zsh completion script
          # Generated by hwaro completion zsh
          #
          # Installation:
          #   eval "$(hwaro completion zsh)"
          # Or save to a file in your fpath:
          #   hwaro completion zsh > ~/.zsh/completions/_hwaro

          _hwaro() {
              local -a commands
              commands=(
          ZSH

          commands.each do |cmd|
            script += "        '#{cmd.name}:#{escape_zsh(cmd.description)}'\n"
          end

          script += <<-ZSH
                  'version:Show version'
                  'help:Show help'
              )

              local -a _command_args

              _arguments -C \\
                  '1: :->command' \\
                  '*:: :->args'

              case $state in
                  command)
                      _describe -t commands 'hwaro commands' commands
                      ;;
                  args)
                      case $words[1] in
          ZSH

          commands.each do |cmd|
            script += generate_zsh_command_case(cmd)
          end

          script += <<-ZSH
                      esac
                      ;;
              esac
          }

          _hwaro "$@"
          ZSH

          script
        end

        private def generate_zsh_command_case(cmd : CommandInfo) : String
          result = "                #{cmd.name})\n"

          # Handle subcommands
          if !cmd.subcommands.empty?
            result += "                    local -a subcommands\n"
            result += "                    subcommands=(\n"
            cmd.subcommands.each do |sub|
              result += "                        '#{sub.name}:#{escape_zsh(sub.description)}'\n"
            end
            result += "                    )\n"
            result += "                    _arguments -C \\\n"
            result += "                        '1: :->subcmd' \\\n"
            result += "                        '*:: :->subargs'\n"
            result += "                    case $state in\n"
            result += "                        subcmd)\n"
            result += "                            _describe -t subcommands '#{cmd.name} subcommands' subcommands\n"
            result += "                            ;;\n"
            result += "                        subargs)\n"
            result += "                            case $words[1] in\n"

            cmd.subcommands.each do |sub|
              result += generate_zsh_subcommand_args(sub)
            end

            result += "                            esac\n"
            result += "                            ;;\n"
            result += "                    esac\n"
          elsif !cmd.positional_choices.empty?
            result += "                    _arguments \\\n"
            result += "                        '1:#{cmd.positional_args.first? || "arg"}:(#{cmd.positional_choices.join(" ")})' \\\n"
            cmd.flags.each_with_index do |flag, i|
              result += generate_zsh_flag(flag, i == cmd.flags.size - 1)
            end
          else
            result += "                    _arguments \\\n"
            cmd.flags.each_with_index do |flag, i|
              result += generate_zsh_flag(flag, i == cmd.flags.size - 1)
            end
          end

          result += "                    ;;\n"
          result
        end

        private def generate_zsh_subcommand_args(sub : CommandInfo) : String
          result = "                                #{sub.name})\n"
          result += "                                    _arguments \\\n"

          if !sub.positional_choices.empty?
            result += "                                        '1:#{sub.positional_args.first? || "arg"}:(#{sub.positional_choices.join(" ")})' \\\n"
          end

          sub.flags.each_with_index do |flag, i|
            is_last = i == sub.flags.size - 1 && sub.positional_choices.empty?
            result += generate_zsh_flag(flag, is_last, "                                        ")
          end

          result += "                                    ;;\n"
          result
        end

        private def generate_zsh_flag(flag : FlagInfo, is_last : Bool, indent : String = "                        ") : String
          short = flag.short
          long = flag.long
          desc = escape_zsh(flag.description)
          trailing = is_last ? "" : " \\"

          if flag.takes_value
            value_hint = flag.value_hint || "value"
            if short
              "#{indent}'(#{short} #{long})'{#{short},#{long}}'[#{desc}]:#{value_hint}:'#{trailing}\n"
            else
              "#{indent}'#{long}[#{desc}]:#{value_hint}:'#{trailing}\n"
            end
          else
            if short
              "#{indent}'(#{short} #{long})'{#{short},#{long}}'[#{desc}]'#{trailing}\n"
            else
              "#{indent}'#{long}[#{desc}]'#{trailing}\n"
            end
          end
        end

        private def generate_fish : String
          commands = Metadata.commands

          script = <<-FISH
          # hwaro fish completion script
          # Generated by hwaro completion fish
          #
          # Installation:
          #   hwaro completion fish | source
          # Or save to a file:
          #   hwaro completion fish > ~/.config/fish/completions/hwaro.fish

          # Disable file completion by default
          complete -c hwaro -f

          # Main commands
          FISH

          commands.each do |cmd|
            script += "complete -c hwaro -n \"__fish_use_subcommand\" -a \"#{cmd.name}\" -d \"#{escape_fish(cmd.description)}\"\n"
          end

          script += "complete -c hwaro -n \"__fish_use_subcommand\" -a \"version\" -d \"Show version\"\n"
          script += "complete -c hwaro -n \"__fish_use_subcommand\" -a \"help\" -d \"Show help\"\n"
          script += "\n"

          commands.each do |cmd|
            script += generate_fish_command(cmd)
          end

          script
        end

        private def generate_fish_command(cmd : CommandInfo) : String
          result = "# #{cmd.name} command\n"

          # Handle subcommands
          unless cmd.subcommands.empty?
            cmd.subcommands.each do |sub|
              result += "complete -c hwaro -n \"__fish_seen_subcommand_from #{cmd.name}; and not __fish_seen_subcommand_from #{cmd.subcommands.map(&.name).join(" ")}\" -a \"#{sub.name}\" -d \"#{escape_fish(sub.description)}\"\n"
            end

            cmd.subcommands.each do |sub|
              result += generate_fish_subcommand(cmd.name, sub)
            end
          else
            # Add flags
            cmd.flags.each do |flag|
              result += generate_fish_flag(cmd.name, flag)
            end

            # Add positional choices
            unless cmd.positional_choices.empty?
              cmd.positional_choices.each do |choice|
                result += "complete -c hwaro -n \"__fish_seen_subcommand_from #{cmd.name}\" -a \"#{choice}\"\n"
              end
            end
          end

          result += "\n"
          result
        end

        private def generate_fish_subcommand(parent : String, sub : CommandInfo) : String
          result = ""
          condition = "__fish_seen_subcommand_from #{parent}; and __fish_seen_subcommand_from #{sub.name}"

          sub.flags.each do |flag|
            result += generate_fish_flag_with_condition(condition, flag)
          end

          unless sub.positional_choices.empty?
            sub.positional_choices.each do |choice|
              result += "complete -c hwaro -n \"#{condition}\" -a \"#{choice}\"\n"
            end
          end

          result
        end

        private def generate_fish_flag(cmd_name : String, flag : FlagInfo) : String
          generate_fish_flag_with_condition("__fish_seen_subcommand_from #{cmd_name}", flag)
        end

        private def generate_fish_flag_with_condition(condition : String, flag : FlagInfo) : String
          parts = ["complete", "-c", "hwaro", "-n", "\"#{condition}\""]

          if short = flag.short
            parts << "-s" << short.lstrip('-')
          end

          parts << "-l" << flag.long.lstrip('-')
          parts << "-d" << "\"#{escape_fish(flag.description)}\""

          if flag.takes_value
            parts << "-r"  # requires argument
          end

          parts.join(" ") + "\n"
        end

        private def escape_zsh(s : String) : String
          s.gsub("'", "'\\''").gsub("[", "\\[").gsub("]", "\\]")
        end

        private def escape_fish(s : String) : String
          s.gsub("\"", "\\\"").gsub("$", "\\$")
        end
      end
    end
  end
end
